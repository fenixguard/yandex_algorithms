"""
ID удачной посылки: 55421203
-----------------------------------------------------------------------------------------------------------------------
Задача
-----------------------------------------------------------------------------------------------------------------------
Тимофей решил организовать соревнование по спортивному программированию, чтобы найти талантливых стажёров. Задачи
подобраны, участники зарегистрированы, тесты написаны. Осталось придумать, как в конце соревнования будет определяться
победитель. Каждый участник имеет уникальный логин. Когда соревнование закончится, к нему будут привязаны два
показателя: количество решённых задач Pi и размер штрафа Fi. Штраф начисляется за неудачные попытки и время,
затраченное на задачу.
Тимофей решил сортировать таблицу результатов следующим образом: при сравнении двух участников выше будет идти тот, у
которого решено больше задач. При равенстве числа решённых задач первым идёт участник с меньшим штрафом. Если же и
штрафы совпадают, то первым будет тот, у которого логин идёт раньше в алфавитном (лексикографическом) порядке.
-----------------------------------------------------------------------------------------------------------------------
Решение
-----------------------------------------------------------------------------------------------------------------------
Часть алгоритма описана в задании, нам остается лишь ее реализовать. Для лучшей читаемости кода и в целом декомпозиции -
разделем основную логику на несколько функций, in_place() - фукнция свапает элементы так, что сначала идут элементы не
превосходящие опорный, а потом превосходящие.
И функция quicksort() - которая определяет опорный элемент, тут есть несколько вариантов, но я предпочел отдать управле-
ние рандому, пусть он выбирает случайный элемент с отрезка (left, right). Находим индекс опорного элемента, делим массив
на два, и запускаем рекурсивно на левой и на правой части массива quicksort().
Таким образом фукнция quicksort() ничего не возвращает, а меняет (сортирует) исходный массив members(). Отсюда делаем
вывод, что дополнительной памяти в реализации алгоритма используется только для стека вызова и равна O(log(n)).
Сложность самого алгоритма как и в лекциях в худшем случае O(n^2), в лучшем и среднем O(n*log(n)).
А для того, чтобы сортировать так как заудмал Тифомей, мы немного изменим входные данные, во-первых на первом месте в
массиве участника будет указано количество задач со знаком минус, чтобы чтобы на первом месте было большее количество
решенных задач. На втором месте количество очков штрафа, так как чем меньше очков тем лучше, значит их оставляем
неизменными, и на третьем месте уже идут имена участников. Таким образом сначала сортировка происходит по первому
элементу, если они равны, то сравниваются вторые элементы, если они равны, то результат выводится в лексикографическом
порядке имен участников.
-----------------------------------------------------------------------------------------------------------------------
Данные посылки 1.236s  21.92Mb

"""
from random import randint
from typing import NoReturn


def in_place(array: list, left: int, right: int, index_pivot: int) -> int:
    array[left], array[index_pivot] = array[index_pivot], array[left]
    pivot = array[left]
    i = left + 1
    j = left + 1
    while j <= right:
        if array[j] <= pivot:
            array[j], array[i] = array[i], array[j]
            i += 1
        j += 1
    array[left], array[i - 1] = array[i - 1], array[left]
    return i - 1


def quicksort(array: list, left: int = 0, right: int = None) -> NoReturn:
    if right is None:
        right = len(array) - 1
    if right - left < 1:
        return

    index_pivot = randint(left, right)
    i = in_place(array, left, right, index_pivot)
    quicksort(array, left, i - 1)  # Запускаем на левой половине
    quicksort(array, i + 1, right)  # Запускаем на правой половине


def solution(members: list):
    quicksort(members)
    for member in members:
        print(member[2])


def input_data() -> list:
    n = int(input())
    members = []
    while n:
        name, p, f = input().strip().split()
        members.append([-int(p), int(f), name])
        n -= 1
    return members


if __name__ == '__main__':
    solution(input_data())
