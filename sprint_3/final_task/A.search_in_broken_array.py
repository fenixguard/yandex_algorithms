"""
ID удачной посылки: 55318080
-----------------------------------------------------------------------------------------------------------------------
Задача
-----------------------------------------------------------------------------------------------------------------------
Алла ошиблась при копировании из одной структуры данных в другую. Она хранила массив чисел в кольцевом буфере. Массив
был отсортирован по возрастанию, и в нём можно было найти элемент за логарифмическое время. Алла скопировала данные из
кольцевого буфера в обычный массив, но сдвинула данные исходной отсортированной последовательности. Теперь массив не
является отсортированным. Тем не менее, нужно обеспечить возможность находить в нем элемент за O(logN).
Можно предполагать, что в массиве только уникальные элементы. (Изменять массив нельзя.)
-----------------------------------------------------------------------------------------------------------------------
Решение
-----------------------------------------------------------------------------------------------------------------------
Попробовал несколько вариантов. Первый вариант был основан на вспомогательной структуре данных. Я использовал словарь,
в нем по ключу хранил значение исходного массива, а в значении его индекс. Далее сортировал исходных массив и бинарным
поиском искал необходимое значение, когда находил, то возвращал его индекс из словаря. Но как оказалось это не работает,
так как нельзя изменять входной массив. И тут я подумал, ну ведь нельзя же реализовать бинарный поиск на неотсортирован-
ном массиве! Но недра интернета подсказали https://www.geeksforgeeks.org/search-an-element-in-a-sorted-and-pivoted-array/
мне обратное и я решил попробовать реализовать бинарный поиск.
Идея, как оказалось, проста. Зоводим левую и правую границу - левая 0, правая длина массива минус 1. Далее в цикле пока
левая граница не станет больше правой происходит само решение. Берем середину - как обычно, складываем границы и делим
пополам. Проверяем под этим индексом искомое значение? если да, то мы нашли ответ к задаче.
Если nums[left] <= nums[middle]:
        а значение target лежим между nums[middle] и nums[left] причем nums[middle] не включая,
        то меняем правую границу, в противном случае - левую.
Если nums[left] > nums[middle]:
        а значение target лежим между nums[middle] и nums[right] причем nums[middle] не включая,
        то меняем левую границу, в противном случае - правую.
В случае, если после прохода всего массива искомое значние не нашлось, то функция вернет -1.
-----------------------------------------------------------------------------------------------------------------------
Сложность алгоритма получается O(logN), где N - длина исходного массива.
Для вычисления искомого значения нам не требуется дополнительная память, мы работает с исходным массивом.
-----------------------------------------------------------------------------------------------------------------------
Данные посылки 416ms 4.07Mb

"""


def broken_search(nums, target) -> int:
    left = 0
    right = len(nums) - 1
    while left <= right:
        middle = (left + right) // 2
        if nums[middle] == target:
            return middle

        if nums[left] <= nums[middle]:
            if nums[middle] > target >= nums[left]:
                right = middle - 1
            else:
                left = middle + 1
        else:
            if nums[middle] < target <= nums[right]:
                left = middle + 1
            else:
                right = middle - 1
    return -1


# def input_data():
#     n = int(input())
#     k = int(input())
#     mass = list(map(int, input().strip().split()))
#     return mass, k
#
#
# if __name__ == '__main__':
#     print(broken_search(*input_data()))


# def test():
#     arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
#     assert broken_search(arr, 5) == 6
