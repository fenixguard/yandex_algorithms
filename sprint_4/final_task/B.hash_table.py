"""
ID удачной посылки: 56859502
------------------------------------------------------------------------------------------------------------------------
Задание
------------------------------------------------------------------------------------------------------------------------
Реализиовать хэш-таблицу без использования встроенных в язык готовых реализаций.
------------------------------------------------------------------------------------------------------------------------
Описание работы алгоритма
------------------------------------------------------------------------------------------------------------------------
В качестве разрешения коллизий возьмем метод цепочек. Для этого создадим класс Node, который будет содержать поля
key, value и next. Обычный связный список.
Для реализации хэш-таблицы заведем класс HashTable. Инициализируем его исходной ёмкостью (размером), и создаем корзины
количеством равное ёмкости таблицы.
Определяем функцию hash, которая проивзодит деление с остатком ключа на ёмкость хэш-таблицы.
И три метода - put, get, delete.
PUT: получает на вход ключ и значение. По ключу генерируем хэш, он явлется индексом корзины. Получаем корзину. Далее
смотрим, если корзина пустая, то записываем пару ключ-значение и выходим. Если в корзине уже лежит элемент, значит
произошла коллизия, в таком случае мы идем по связному списку, если ключ в списке совпадаем с пришедшим, то перезапи -
сываем значение, а если ключ не совпал, то добавялем элемент в конец связного списка.
GET: принимает на вход ключ. По ключу генерируем хэш, он явлется индексом корзины. Получаем корзину. В корзине лежит
голова связного списка, пока она не пустая и ключ лежащий в списке не равен пришедшему ключу мы двигаемся дальше по
списку. Если дошли до конца, а ключ так и не совпал значит элемента нет и мы вовзращаем None, в противном случае воз-
вращаем значение.
DELETE: принимает на вход ключ. По ключу генерируем хэш, он явлется индексом корзины. Получаем корзину. Ищем также как и
в методе GET, но если нашли, тогда в результат сохраняем значение, чтобы его вернуть, и меняем указатель предыдущего
элемента связного списка, так как искомый элемент был удален.

P.S.: Ввод пришлось делать внутри основной функции, так как по памяти не проходил, если сохранял все запросы в массив.
------------------------------------------------------------------------------------------------------------------------
Сложность
------------------------------------------------------------------------------------------------------------------------
Временная - все методы в среднем выпполняются за O(1)
Пространственная - O(n) - где n - размер хэш-таблицы.
------------------------------------------------------------------------------------------------------------------------
Данные посылки
------------------------------------------------------------------------------------------------------------------------
12.829s 33.63Mb
------------------------------------------------------------------------------------------------------------------------
"""

from typing import NoReturn, Optional

INITIAL_CAPACITY = 1000009  # Большое простое число


class Node:
    def __init__(self, key: int, value: int):
        self.key = key
        self.value = value
        self.next = None


class HashTable:
    def __init__(self):
        self.capacity = INITIAL_CAPACITY
        self.buckets = [None] * self.capacity

    def hash(self, key: int) -> int:
        return key % self.capacity

    def put(self, key: int, value: int) -> NoReturn:
        index = self.hash(key)
        node = self.buckets[index]
        if node is None:
            self.buckets[index] = Node(key, value)
            return
        prev = node
        while node is not None:
            if node.key == key:
                node.value = value
                return
            else:
                prev = node
                node = node.next
        prev.next = Node(key, value)

    def get(self, key: int) -> Optional[int]:
        index = self.hash(key)
        node = self.buckets[index]
        while node is not None and node.key != key:
            node = node.next
        if node is None:
            return None
        else:
            return node.value

    def delete(self, key: int) -> Optional[int]:
        index = self.hash(key)
        node = self.buckets[index]
        prev = None
        while node is not None and node.key != key:
            prev = node
            node = node.next
        if node is None:
            return None
        else:
            result = node.value
            if prev is None:
                self.buckets[index] = node.next
            else:
                prev.next = prev.next.next
            return result


def solution() -> NoReturn:
    h = HashTable()
    operations = {
        'put': h.put,
        'get': h.get,
        'delete': h.delete,
    }
    n = int(input())
    while n:
        row = input().strip().split()
        method = operations.get(row[0])
        if method.__name__ == 'put':
            method(int(row[1]), int(row[2]))
        else:
            print(method(int(row[1])))
        n -= 1


if __name__ == '__main__':
    solution()
