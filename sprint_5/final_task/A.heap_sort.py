"""
ID успешной посылки: 58917267
-------------------------------------------------------------------------------
Задача:
Реализовать сортировку кучей. Данные должны быть отсортированы по следующему
принципу:
Сначала у кого больше решенных задач, при равных условиях, у кого меньше
штрафа, при равных условиях, имена в лексикографическом порядке.
-------------------------------------------------------------------------------
Алгоритм:
С точно такой же задачей я сталкивался раньше и решал ее обычной сортировкой и
потом ломал голову, почему она не укладывается по времени. Теперь я понял как
нужно ее решать правильно :D
У нас будет вспомогательная функция heapify, которая за линейное время преоб-
разует список в кучу. А основная фукнция сортировки heap_sort. В ней мы на
списке, который состоит из (-очки_за _решение_задачи, штрафные_баллы, имя)
запускаем создание кучи, причем важно отметить, что куча создается снизу вверх.
После того как получили кучу, теперь наши значения в ней отсортированы по
убыванию. В голове самый большой. Проведем процедуру извлечения элементов.
Меняем корень дерева с последним элементом и снова запускаем функцию heapify,
но уже на уменьшенной куче.
Таким образом на выходе у нас получится отсортированны массив.
-------------------------------------------------------------------------------
Сложность:
Временная O(n*log(n)). Так как высота полного бинарного дерева, содержащего n
элементов равна O(log(n)).
Пространственная сложность O(1).
-------------------------------------------------------------------------------
Данные посылки: 1.676s 20.21Mb
-------------------------------------------------------------------------------
"""

from typing import List, NoReturn, Tuple


def heapify(members: List[Tuple[int, int, str]], n: int, i: int) -> NoReturn:
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    if left < n and members[i] < members[left]:
        largest = left
    if right < n and members[largest] < members[right]:
        largest = right

    if largest != i:
        members[i], members[largest] = members[largest], members[i]
        heapify(members, n, largest)


def heap_sort(members: List[Tuple[int, int, str]], n: int) -> NoReturn:

    for i in range(n, -1, -1):
        heapify(members, n, i)

    for i in range(n - 1, 0, -1):
        members[i], members[0] = members[0], members[i]
        heapify(members, i, 0)


def print_members_name(members: List[Tuple[int, int, str]]) -> NoReturn:
    n = len(members)
    heap_sort(members, n)
    for i in range(n):
        print(members[i][2])


def input_data() -> List[Tuple[int, int, str]]:
    n = int(input())
    members = []
    while n:
        name, p, f = input().strip().split()
        members.append((-int(p), int(f), name))
        n -= 1
    return members


if __name__ == '__main__':
    print_members_name(input_data())
